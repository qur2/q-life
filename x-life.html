<link rel="import" href="../polymer/polymer.html">

<!--
Element providing solution to no problem in particular.

##### Example

		<seed-element></seed-element>

@element seed-element
@blurb Element providing solution to no problem in particular.
@status alpha
@homepage http://polymerlabs.github.io/seed-element
-->
<polymer-element name="x-life" attributes="width height geom">

	<template>

		<link rel="stylesheet" href="x-life.css" />
		<canvas id='gol-container' width={{width}} height={{height}} geom={{geom}}></canvas>

	</template>

	<script>
		/**
		 * Helper function to sum the elements of an array.
		 * Bind an array to it and call `array.sum()` or call
		 * it directly with `array.call(array)`.
		 * Provided as an alternative to modifying prototypes
		 * or subclassing native types.
		 *
		 * @function arraySum
		 * @return {Number} The sum of the array elements.
		 */
		var arraySum = function() {
			var total = 0;
			var i = this.length;
			while (i--) {
				total += this[i];
			}
			return total;
		};

		var RectMixin = {
			setupGrid: function() {
				this.cols = Math.floor(this.width / this.cellSize);
				this.rows = Math.floor(this.height / this.cellSize);
			},
			proximity: function(i) {
				var c, x, y, cells = this.cells;
				c = this.itocoord(i);
				x = c[0]; y = c[1];
				return [
					cells[this.coordtoi(x-1, y-1)],
					cells[this.coordtoi(x, y-1)],
					cells[this.coordtoi(x+1, y-1)],
					cells[this.coordtoi(x-1, y)],
					cells[this.coordtoi(x+1, y)],
					cells[this.coordtoi(x-1, y+1)],
					cells[this.coordtoi(x, y+1)],
					cells[this.coordtoi(x+1, y+1)]
				]
			},
			paintCell: function(coord) {
				this.ctx.fillRect(
					coord[0]*this.cellSize, coord[1]*this.cellSize,
					this.cellSize, this.cellSize
				);
			},

		};

		var polygon = function(ctx, x, y, radius, sides, startAngle) {
			if (sides < 3) return;
			ctx.beginPath();
			var a = (Math.PI * 2)/sides;
			ctx.save();
			ctx.translate(x, y);
			ctx.rotate(startAngle);
			ctx.moveTo(radius, 0);
			while (sides--) {
				ctx.lineTo(radius*Math.cos(-a*sides), radius*Math.sin(-a*sides));
			}
			ctx.closePath();
			ctx.fill();
			ctx.restore();
		};

		var HexMixin = {
			setupGrid: function() {
				this.cols = Math.floor(this.width / (this.cellSize/Math.sqrt(3)));
				this.rows = Math.floor(this.height / this.cellSize);
			},
			proximity: function(i) {
				var c, x, y, cells = this.cells;
				c = this.itocoord(i);
				x = c[0]; y = c[1];
				return [
					cells[this.coordtoi(x-1, y-1 + (x&1))],
					cells[this.coordtoi(x-1, y + (x&1))],
					cells[this.coordtoi(x, y-1)],
					cells[this.coordtoi(x, y+1)],
					cells[this.coordtoi(x+1, y-1 + (x&1))],
					cells[this.coordtoi(x+1, y + (x&1))]
				];
			},
			paintCell: function(coord) {
				var w = this.cellSize / Math.sqrt(3);

				var x = ((coord[1]+0.5)+(coord[0]%2)*0.5)*(Math.sqrt(3)*w),
					y = coord[0]*(3/4*w*2)+w;

				polygon(this.ctx, x, y, this.cellSize/2, 6, Math.PI/2);
			}
		};

		var mixinMap = {
			'rect': RectMixin,
			'hex': HexMixin
		};

		Polymer('x-life', {

			width: 480,
			height: 480,
			cellSize: 5,
			geom: 'rect',
			backgroundColor: 'rgb(147,147,247)',

			/**
			 * Computes 2D coordinates to 1D index.
			 *
			 * @method coordtoi
			 * @param {int} The x-coordinate.
			 * @param {int} The y-coordinate.
			 * @return {int} The 1D index.
			 */
			coordtoi: function(x, y) {
				return (((y+this.rows) % this.rows) * this.cols) + ((x+this.cols) % this.cols);
			},

			/**
			 * Computes 1D index to 2D coordinates.
			 *
			 * @method coordtoi
			 * @param {int} The 1D index.
			 * @return {Array} [x, y] the 2D-coordinates.
			 */
			itocoord: function(i) {
				var x, y;
				x = i % this.cols;
				y = Math.floor(i / this.cols);
				return [x, y];
			},

			age: function (cell, neighbors) {
				var neighSum = arraySum.call(neighbors);
				if (neighSum === 2 && cell) return 1;
				if (neighSum === 3) return 1;
				return 0;
			},

			tick: function(coord) {
				this.ctx.fillStyle = this.backgroundColor;
				this.ctx.fillRect(0, 0, this.width, this.height);
				this.ctx.fillStyle = 'rgb(0,0,0)';
				var cells = this.cells,
					cells2 = this.cells2,
					i = cells.length;
				while (i--) {
					neighs = this.proximity(i);
					cells2[i] = this.age(cells[i], neighs);
					if (cells2[i]) {
						this.paintCell(this.itocoord(i));
					}
				}
				this.cells = cells2;
				this.cells2 = cells;
			},

			arrayFill: function(mat, l, fill) {
				fill || (fill = 0);
				var i = mat.length;
				while (i--) {
					mat[i] = fill;
				}
			},

			ready: function() {
				// Ready is a lifecycle callback.
				// You can do setup work in here.
				// More info: http://www.polymer-project.org/docs/polymer/polymer.html#lifecyclemethods
				for (prop in mixinMap[this.geom]) {
					this[prop] = mixinMap[this.geom][prop].bind(this);
				}
				this.setupGrid();
				this.cells = new Uint8ClampedArray(this.cols * this.rows);
				this.cells.sum = arraySum.bind(this.cells);
				this.cells2 = new Uint8ClampedArray(this.cols * this.rows);
				this.cells2.sum = arraySum.bind(this.cells2);
				this.arrayFill(this.cells, this.cols * this.rows);
				var canvas = this.$["gol-container"];
				this.ctx = canvas.getContext("2d");
				this.ctx.fillStyle = this.backgroundColor;
				this.ctx.fillRect(0, 0, this.width, this.height);
				this.ctx.fillStyle = 'rgb(0,0,0)';

				var i=Math.ceil(this.cells.length/20);
				while (i--) {
					j = Math.floor(Math.random() * this.cells.length);
					this.cells[j] = 1;
					this.paintCell(this.itocoord(j));
				}

				this.play(150);
			},

			/**
			 * Starts the game.
			 *
			 * @method play
			 * @param {int} The frequency of the timer, in ms.
			 * @return {Object} The x-life instance.
			 */
			play: function(freq) {
				if (this.clock == undefined){
					var tick = this.tick.bind(this);
					this.clock = setInterval(function(){
						tick();
					}, freq);
				}
			},

			/**
			 * Stops the game.
			 *
			 * @method stop
			 * @return {Object} The x-life instance.
			 */
			stop: function() {
				if (this.clock != undefined){
					window.clearInterval(this.clock);
				}
				return this;
			},

		});

	</script>

</polymer-element>
